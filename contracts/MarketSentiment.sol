// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
// Uncomment this line to use console.log
// import "hardhat/console.sol";

contract FirstDapp is Ownable {
   struct ticket  {
        mapping  (string=>string) ticketName;
        uint  votesPositive;
        uint votesNegative;
        mapping(address=>bool) addressVoted;
    } 
    mapping (string=>ticket) _newTicket;
    mapping(string=>bool) public tokenExist;
    event tokenCreated(string str);
   string[] tokenList;

 //Tickets generated by owner
    function createTicket(string memory _str) public onlyOwner {
        require(!tokenExist[_str],"Ticket already exist");
        tokenExist[_str]=true;
       ticket storage newTicket = _newTicket[_str];
        newTicket.votesPositive=0;
        newTicket.votesNegative=0;
        tokenList.push(_str);
        emit tokenCreated(_str);
    }
// Ask for tickets cretead
    function getTickets () public view  returns (string[] memory) {
        return tokenList;
    }    
// Voting
    function votePositive(string memory _str) public {
        require(!_newTicket[_str].addressVoted[msg.sender], "This address has already voted");
        _newTicket[_str].votesPositive+=1;
        _newTicket[_str].addressVoted[msg.sender]=true;
    }
    function getPositiveVotes (string memory _str) public view returns (uint){
        return _newTicket[_str].votesPositive;
    }
     function voteNegative(string memory _str) public {
        require(!_newTicket[_str].addressVoted[msg.sender], "This address has already voted");
        _newTicket[_str].votesNegative+=1;
        _newTicket[_str].addressVoted[msg.sender]=true;
    }
    function getNegativeVotes (string memory _str) public view returns (uint){
        return _newTicket[_str].votesNegative;
    }

}
